<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr List Reader</title>
    <style>
        :root {
            --primary-color: #6366f1;
            --background-color: #1a1b26;
            --text-color: #a9b1d6;
            --card-background: #24283b;
            --border-color: #414868;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: white;
            margin-bottom: 10px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        input, button, textarea, select {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        input, textarea {
            flex: 1;
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .list-card {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .list-card.deleted {
            opacity: 0.7;
            border: 1px solid #4b5563;
        }

        .list-card.deleted .list-title::before {
            content: 'üóëÔ∏è ';
        }

        .list-card.deleting {
            opacity: 0.7;
            border: 1px solid #4b5563;
            transition: all 0.3s ease;
        }

        .list-card.deleting .list-title::before {
            content: 'üóëÔ∏è ';
        }

        .list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .list-header h3 {
            margin: 0;
        }

        .list-title {
            color: white;
            margin: 0 0 10px 0;
        }

        .list-description {
            margin-bottom: 15px;
            color: var(--text-color);
        }

        .list-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .list-item {
            background: var(--background-color);
            color: var(--text-color);
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .list-item:hover {
            background: var(--border-color);
        }

        .list-meta {
            font-size: 12px;
            color: var(--text-color);
            opacity: 0.8;
        }

        .relay-info {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 5px;
            border-top: 1px solid #374151;
            padding-top: 5px;
        }

        .error {
            color: #f87171;
            padding: 10px;
            border-radius: 6px;
            background: rgba(248, 113, 113, 0.1);
            margin-bottom: 20px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-color);
        }

        .user-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background: var(--card-background);
            border-radius: 8px;
        }

        .create-list-section {
            display: none;
            background: var(--card-background);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .create-list-section.visible {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: white;
        }

        .tag-input {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .tag {
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tag button {
            background: none;
            border: none;
            color: white;
            padding: 0;
            cursor: pointer;
            font-size: 16px;
        }

        .delete-button {
            background: #f87171;
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            transition: opacity 0.2s;
            border-radius: 6px;
            font-size: 14px;
        }

        .delete-button:hover {
            opacity: 0.9;
        }

        .delete-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #6b7280;
        }

        .edit-button {
            background: #6366f1;
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 10px;
            font-size: 14px;
        }

        .edit-button:hover {
            opacity: 0.9;
        }

        .edit-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #6b7280;
        }

        .version-badge {
            font-size: 12px;
            padding: 2px 6px;
            background: #4b5563;
            border-radius: 4px;
            margin-left: 8px;
            color: #e5e7eb;
        }

        .version-history {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #374151;
        }

        .version-item {
            padding: 4px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .version-item button {
            background: none;
            border: none;
            color: #6366f1;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 6px;
        }

        .version-item button:hover {
            text-decoration: underline;
        }

        .accordion-toggle {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            opacity: 0.8;
        }

        .accordion-toggle:hover {
            opacity: 1;
        }

        .accordion-content {
            display: none;
        }

        .accordion-content.visible {
            display: block;
        }

        .clear-cache {
            background: #4b5563;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 14px;
        }

        .clear-cache:hover {
            background: #6b7280;
        }

        .relay-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .relay-status.available {
            background: #10b981;  /* green */
        }

        .relay-status.deleted {
            background: #ef4444;  /* red */
        }

        .relay-status.unknown {
            background: #f59e0b;  /* yellow */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Nostr List Reader</h1>
            <p>View and create lists (kind:30001 & kind:30003)</p>
        </div>

        <div class="user-section">
            <div id="login-status">Not logged in</div>
            <button id="loginButton">Login with Nostr</button>
        </div>

        <div class="input-group">
            <input type="text" id="pubkey" placeholder="Enter npub...">
            <button id="fetchButton">Fetch Lists</button>
            <button id="clearCache" class="clear-cache">Clear Cache</button>
        </div>

        <div id="create-list-section" class="create-list-section">
            <h3>Create New List</h3>
            <div class="form-group">
                <label for="listType">List Type</label>
                <select id="listType">
                    <option value="30001">Categorized List (30001)</option>
                    <option value="30003">Bookmark Set (30003) - for grouped bookmarks of notes, articles, hashtags, URLs</option>
                </select>
            </div>
            <div class="form-group">
                <label for="listTitle">Title</label>
                <input type="text" id="listTitle" placeholder="Enter list title">
            </div>
            <div class="form-group">
                <label for="listDescription">Description</label>
                <textarea id="listDescription" rows="3" placeholder="Enter list description"></textarea>
            </div>
            <div class="form-group">
                <label>Add Items</label>
                <div class="tag-input">
                    <input type="text" id="itemInput" placeholder="Enter note ID, pubkey, or URL">
                    <input type="text" id="itemLabel" placeholder="Label (optional)">
                    <button id="addItemButton">Add</button>
                </div>
                <div id="itemsContainer" class="tags-container"></div>
            </div>
            <button id="createListButton">Create List</button>
        </div>

        <div id="lists-container"></div>
    </div>

    <script>
        // Default relays to use
        const DEFAULT_RELAYS = [
            'wss://relay.damus.io',
            'wss://nos.lol',
            'wss://relay.nostr.band',
            'wss://nostr.mom'
        ];

        let currentUser = null;
        let listItems = [];

        // Initialize login status
        async function checkLoginStatus() {
            try {
                if (typeof window.nostr === 'undefined') {
                    throw new Error('No Nostr extension found');
                }
                const pubkey = await window.nostr.getPublicKey();
                currentUser = pubkey;

                // Fetch user profile
                const profileEvents = [];
                const promises = DEFAULT_RELAYS.map(relay => new Promise(async (resolve) => {
                    try {
                        const ws = new WebSocket(relay);
                        
                        ws.onopen = () => {
                            const subId = Math.random().toString(36).substring(7);
                            ws.send(JSON.stringify([
                                "REQ",
                                subId,
                                {
                                    authors: [pubkey],
                                    kinds: [0],
                                    limit: 1
                                }
                            ]));
                        };

                        ws.onmessage = (e) => {
                            const [type, subId, event] = JSON.parse(e.data);
                            if (type === "EVENT") {
                                profileEvents.push(event);
                                ws.close();
                                resolve();
                            } else if (type === "EOSE") {
                                ws.close();
                                resolve();
                            }
                        };

                        setTimeout(() => {
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.close();
                            }
                            resolve();
                        }, 3000);

                        ws.onerror = () => resolve();
                    } catch (error) {
                        resolve();
                    }
                }));

                await Promise.all(promises);

                // Get the latest profile event
                let displayName = pubkey.slice(0, 8) + '...';
                if (profileEvents.length > 0) {
                    // Sort by created_at to get the latest
                    profileEvents.sort((a, b) => b.created_at - a.created_at);
                    try {
                        const profile = JSON.parse(profileEvents[0].content);
                        if (profile.display_name || profile.name) {
                            displayName = profile.display_name || profile.name;
                        }
                    } catch (e) {
                        console.error('Failed to parse profile:', e);
                    }
                }

                document.getElementById('login-status').textContent = `Logged in as: ${displayName}`;
                document.getElementById('loginButton').textContent = 'Logout';
                document.getElementById('create-list-section').classList.add('visible');
            } catch (error) {
                currentUser = null;
                document.getElementById('login-status').textContent = 'Not logged in';
                document.getElementById('loginButton').textContent = 'Login with Nostr';
                document.getElementById('create-list-section').classList.remove('visible');
            }
        }

        // Handle login/logout
        document.getElementById('loginButton').addEventListener('click', async () => {
            if (currentUser) {
                currentUser = null;
                await checkLoginStatus();
            } else {
                try {
                    await window.nostr.getPublicKey();
                    await checkLoginStatus();
                } catch (error) {
                    alert('Failed to login: ' + error.message);
                }
            }
        });

        // Handle adding items to the list
        document.getElementById('addItemButton').addEventListener('click', () => {
            const input = document.getElementById('itemInput');
            const label = document.getElementById('itemLabel');
            const value = input.value.trim();
            const labelText = label.value.trim();

            if (!value) return;

            const item = { value, label: labelText || value };
            listItems.push(item);
            updateItemsDisplay();

            input.value = '';
            label.value = '';
        });

        // Update items display
        function updateItemsDisplay() {
            const container = document.getElementById('itemsContainer');
            container.innerHTML = listItems.map((item, index) => `
                <div class="tag">
                    ${item.label}
                    <button onclick="removeItem(${index})">√ó</button>
                </div>
            `).join('');
        }

        // Remove item from list
        window.removeItem = function(index) {
            listItems.splice(index, 1);
            updateItemsDisplay();
        };

        // Create and publish a new list
        document.getElementById('createListButton').addEventListener('click', async () => {
            if (!currentUser) {
                alert('Please login first');
                return;
            }

            const title = document.getElementById('listTitle').value.trim();
            const description = document.getElementById('listDescription').value.trim();
            const kind = parseInt(document.getElementById('listType').value);

            if (!title || listItems.length === 0) {
                alert('Please enter a title and add at least one item');
                return;
            }

            try {
                const event = {
                    kind,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['title', title],
                        ['description', description],
                        ...listItems.map(item => {
                            // Determine if it's a note (e), person (p), or URL (l)
                            let type = 'l'; // default to URL
                            if (item.value.startsWith('npub1') || item.value.length === 64) {
                                type = 'p';
                            } else if (item.value.startsWith('note1') || item.value.length === 64) {
                                type = 'e';
                            }
                            return [type, item.value, '', item.label];
                        })
                    ],
                    content: description
                };

                const signedEvent = await window.nostr.signEvent(event);
                
                // Publish to relays
                let published = false;
                for (const relay of DEFAULT_RELAYS) {
                    if (published) break;
                    
                    try {
                        const ws = new WebSocket(relay);
                        
                        await new Promise((resolve, reject) => {
                            ws.onopen = () => {
                                ws.send(JSON.stringify(["EVENT", signedEvent]));
                            };

                            ws.onmessage = (e) => {
                                const [type, eventId, success, message] = JSON.parse(e.data);
                                if (type === "OK" && success) {
                                    published = true;
                                    console.log(`Published to relay ${relay}: ${eventId}`);
                                    ws.close();
                                    resolve();
                                }
                            };

                            setTimeout(() => {
                                if (ws.readyState === WebSocket.OPEN) {
                                    ws.close();
                                }
                                resolve();
                            }, 3000);

                            ws.onerror = () => resolve();
                        });
                    } catch (error) {
                        console.error(`Failed to publish to ${relay}:`, error);
                    }
                }

                if (!published) {
                    throw new Error('Failed to publish to any relay');
                }
                alert('List created successfully!');

                // Clear form
                document.getElementById('listTitle').value = '';
                document.getElementById('listDescription').value = '';
                listItems = [];
                updateItemsDisplay();

                // Fetch lists to show the new one
                if (currentUser) {
                    document.getElementById('pubkey').value = currentUser;
                    fetchLists();
                }
            } catch (error) {
                alert('Error creating list: ' + error.message);
            }
        });

        // Helper function to connect to a relay with timeout
        async function connectToRelay(relay, timeout = 3000) {
            return new Promise((resolve, reject) => {
                try {
                    const ws = new WebSocket(relay);
                    
                    const timeoutId = setTimeout(() => {
                        if (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN) {
                            ws.close();
                            resolve({ ws: null, error: 'Timeout' });
                        }
                    }, timeout);

                    ws.onopen = () => {
                        clearTimeout(timeoutId);
                        resolve({ ws, error: null });
                    };

                    ws.onerror = (error) => {
                        clearTimeout(timeoutId);
                        resolve({ ws: null, error: `Failed to connect to ${relay}` });
                    };
                } catch (error) {
                    resolve({ ws: null, error: error.message });
                }
            });
        }

        // Helper function to publish event to a relay
        async function publishToRelay(relay, event) {
            const { ws, error } = await connectToRelay(relay);
            if (error || !ws) {
                console.warn(`Skipping ${relay}: ${error}`);
                return false;
            }

            return new Promise((resolve) => {
                const timeoutId = setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                    resolve(false);
                }, 3000);

                ws.onmessage = (e) => {
                    const [type, eventId, success, message] = JSON.parse(e.data);
                    if (type === "OK" && success) {
                        clearTimeout(timeoutId);
                        console.log(`Published to ${relay}: ${eventId}`);
                        ws.close();
                        resolve(true);
                    }
                };

                ws.send(JSON.stringify(["EVENT", event]));
            });
        }

        // Cache management functions
        const CACHE_PREFIX = 'nostr_lists_v1_'; // Version the cache to avoid conflicts
        const CACHE_EXPIRY = 60 * 60 * 1000; // 1 hour in milliseconds

        function getCacheKey(pubkey) {
            return `${CACHE_PREFIX}${pubkey}`;
        }

        function getAllCacheKeys() {
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(CACHE_PREFIX)) {
                    keys.push(key);
                }
            }
            return keys;
        }

        function clearAllCache() {
            const keys = getAllCacheKeys();
            keys.forEach(key => {
                try {
                    localStorage.removeItem(key);
                    console.log('Removed cache key:', key);
                } catch (error) {
                    console.error('Failed to remove cache key:', key, error);
                }
            });
            return keys.length;
        }

        function clearCacheForPubkey(pubkey) {
            const key = getCacheKey(pubkey);
            try {
                localStorage.removeItem(key);
                console.log('Removed cache for pubkey:', pubkey);
                return true;
            } catch (error) {
                console.error('Failed to remove cache for pubkey:', pubkey, error);
                return false;
            }
        }

        // Save lists to localStorage
        function cacheLists(pubkey, data) {
            try {
                const key = getCacheKey(pubkey);
                localStorage.setItem(key, JSON.stringify({
                    ...data,
                    timestamp: Date.now()
                }));
                console.log('Cached lists for pubkey:', pubkey);
                return true;
            } catch (error) {
                console.error('Failed to cache lists:', error);
                return false;
            }
        }

        // Get cached lists from localStorage
        function getCachedLists(pubkey) {
            try {
                const key = getCacheKey(pubkey);
                const cached = localStorage.getItem(key);
                if (!cached) {
                    return null;
                }

                const data = JSON.parse(cached);
                
                // Check if cache is expired
                if (Date.now() - data.timestamp > CACHE_EXPIRY) {
                    console.log('Cache expired for pubkey:', pubkey);
                    clearCacheForPubkey(pubkey);
                    return null;
                }

                console.log('Found valid cache for pubkey:', pubkey);
                return {
                    events: data.events,
                    deletions: new Set(data.deletions)
                };
            } catch (error) {
                console.error('Failed to get cached lists:', error);
                clearCacheForPubkey(pubkey);
                return null;
            }
        }

        function clearCache() {
            const count = clearAllCache();
            alert(`Cleared ${count} cached items!`);
            
            // Clear the current display
            const container = document.getElementById('lists-container');
            container.innerHTML = '';
            
            // Re-fetch if we have a pubkey
            const pubkeyInput = document.getElementById('pubkey');
            if (pubkeyInput.value.trim()) {
                fetchLists();
            }
        }

        async function fetchLists() {
            const container = document.getElementById('lists-container');
            const pubkeyInput = document.getElementById('pubkey');
            const npub = pubkeyInput.value.trim();

            if (!npub) {
                container.innerHTML = '<div class="error">Please enter an npub</div>';
                return;
            }

            // Convert npub to hex
            const hexPubkey = npubToHex(npub);

            // Check cache first
            const cachedLists = getCachedLists(hexPubkey);
            if (cachedLists) {
                console.log('Using cached lists:', cachedLists);
                displayLists(cachedLists.events, cachedLists.deletions);
                return;
            }

            container.innerHTML = '<div class="loading">Fetching lists...</div>';

            try {
                // Calculate timestamp for 1 year ago
                const oneYearAgo = Math.floor(Date.now() / 1000) - (365 * 24 * 60 * 60);

                // Create WebSocket connections to relays
                const eventsMap = new Map(); // Use Map to deduplicate by event ID
                const deletions = new Set(); // Track deleted event IDs
                const relayResponses = new Map(); // Track which relays have the event

                console.log('Starting relay connections...');

                const promises = DEFAULT_RELAYS.map(relay => new Promise(async (resolve) => {
                    try {
                        const ws = new WebSocket(relay);
                        
                        ws.onopen = () => {
                            console.log(`Connected to ${relay}`);
                            // Send subscription request for both lists and deletions
                            const subId = Math.random().toString(36).substring(7);
                            ws.send(JSON.stringify([
                                "REQ",
                                subId,
                                {
                                    authors: [hexPubkey],
                                    kinds: [30001, 30003, 5], // Include kind:5 for deletions
                                    since: oneYearAgo
                                }
                            ]));
                        };

                        ws.onmessage = (e) => {
                            const [type, subId, event] = JSON.parse(e.data);
                            if (type === "EVENT") {
                                if (event.kind === 5) {
                                    // Add deleted event IDs to the set
                                    event.tags
                                        .filter(t => t[0] === 'e')
                                        .forEach(t => deletions.add(t[1]));
                                    console.log(`Found deletion event for: ${event.tags.filter(t => t[0] === 'e').map(t => t[1]).join(', ')}`);
                                } else {
                                    // Store event and track which relay it came from
                                    console.log(`Found event ${event.id} from ${relay}`);
                                    eventsMap.set(event.id, event);
                                    if (!relayResponses.has(event.id)) {
                                        relayResponses.set(event.id, new Set());
                                    }
                                    relayResponses.get(event.id).add(relay);
                                }
                            } else if (type === "EOSE") {
                                console.log(`End of stored events from ${relay}`);
                                ws.close();
                                resolve();
                            }
                        };

                        // Set timeout for relay
                        setTimeout(() => {
                            if (ws.readyState === WebSocket.OPEN) {
                                console.log(`Timeout reached for ${relay}`);
                                ws.close();
                            }
                            resolve();
                        }, 3000);

                        ws.onerror = (error) => {
                            console.error(`Error with ${relay}:`, error);
                            resolve();
                        };
                    } catch (error) {
                        console.error(`Failed to connect to ${relay}:`, error);
                        resolve();
                    }
                }));

                // Wait for all relays to respond or timeout
                await Promise.all(promises);

                console.log('All relay connections completed');
                console.log('Unique events found:', eventsMap.size);
                console.log('Events by ID:', Array.from(eventsMap.keys()));

                // Convert Map to array and add relay information
                const events = Array.from(eventsMap.values()).map(event => ({
                    ...event,
                    relays: Array.from(relayResponses.get(event.id) || [])
                }));
                
                // Cache the results
                cacheLists(hexPubkey, { events, deletions: Array.from(deletions) });

                console.log('Final events to display:', events.length);
                displayLists(events, deletions);
            } catch (error) {
                console.error('Error in fetchLists:', error);
                container.innerHTML = `<div class="error">Error fetching lists: ${error.message}</div>`;
            }
        }

        function toggleAccordion(eventId) {
            const content = document.getElementById(`content-${eventId}`);
            content.classList.toggle('visible');
            const button = document.getElementById(`toggle-${eventId}`);
            button.textContent = content.classList.contains('visible') ? 'Hide Details ‚ñº' : 'Show Details ‚ñ∂';
        }

        window.deleteList = async function(eventId) {
            if (!currentUser) {
                alert('Please login first');
                return;
            }

            if (!confirm('Are you sure you want to delete this list?')) {
                return;
            }

            // Immediately update UI
            const listCard = document.querySelector(`[data-event-id="${eventId}"]`);
            const deleteButton = listCard.querySelector('.delete-button');
            const contentDiv = listCard.querySelector('.list-content');
            const title = listCard.querySelector('.list-title');
            
            // Update UI to show deleting state
            listCard.classList.add('deleting');
            deleteButton.classList.add('disabled');
            deleteButton.textContent = 'Deleting...';
            deleteButton.disabled = true;
            
            // Hide content and add toggle button
            contentDiv.style.display = 'none';
            const toggleBtn = document.createElement('button');
            toggleBtn.id = `toggle-${eventId}`;
            toggleBtn.className = 'accordion-toggle';
            toggleBtn.textContent = 'Show Details ‚ñ∂';
            toggleBtn.onclick = () => toggleAccordion(eventId);
            
            // Add toggle button after title
            title.insertAdjacentElement('afterend', toggleBtn);
            
            // Create accordion content div
            const accordionContent = document.createElement('div');
            accordionContent.id = `content-${eventId}`;
            accordionContent.className = 'accordion-content';
            accordionContent.innerHTML = contentDiv.innerHTML;
            contentDiv.parentNode.insertBefore(accordionContent, contentDiv.nextSibling);
            contentDiv.remove();

            try {
                // Create deletion event (kind:5)
                const event = {
                    kind: 5,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['e', eventId]],
                    content: ''
                };

                const signedEvent = await window.nostr.signEvent(event);
                
                // Try publishing to each relay until we succeed
                let published = false;
                for (const relay of DEFAULT_RELAYS) {
                    if (published) break;
                    published = await publishToRelay(relay, signedEvent);
                }

                if (!published) {
                    throw new Error('Failed to publish deletion to any relay');
                }

                // Update button text after successful deletion
                deleteButton.textContent = 'Deleted';
                title.textContent = title.textContent + ' (Deleted)';

                // Update cache to mark this event as deleted
                const pubkeyInput = document.getElementById('pubkey');
                const hexPubkey = npubToHex(pubkeyInput.value.trim());
                const cached = localStorage.getItem(`nostr_lists_${hexPubkey}`);
                if (cached) {
                    const data = JSON.parse(cached);
                    data.deletions = [...new Set([...data.deletions, eventId])];
                    localStorage.setItem(`nostr_lists_${hexPubkey}`, JSON.stringify(data));
                }
            } catch (error) {
                // Revert UI changes on error
                listCard.classList.remove('deleting');
                deleteButton.classList.remove('disabled');
                deleteButton.textContent = 'Delete List';
                deleteButton.disabled = false;
                contentDiv.style.display = 'block';
                if (toggleBtn) toggleBtn.remove();
                if (accordionContent) accordionContent.remove();
                alert('Error deleting list: ' + error.message);
            }
        };

        async function checkEventStatusOnRelay(relay, eventId) {
            return new Promise(async (resolve) => {
                try {
                    const ws = new WebSocket(relay);
                    let status = 'unknown';
                    
                    ws.onopen = () => {
                        const subId = Math.random().toString(36).substring(7);
                        ws.send(JSON.stringify([
                            "REQ",
                            subId,
                            {
                                ids: [eventId]
                            }
                        ]));

                        // Also check for deletion events
                        const delSubId = Math.random().toString(36).substring(7);
                        ws.send(JSON.stringify([
                            "REQ",
                            delSubId,
                            {
                                kinds: [5],
                                "#e": [eventId]
                            }
                        ]));
                    };

                    ws.onmessage = (e) => {
                        const [type, subId, event] = JSON.parse(e.data);
                        if (type === "EVENT") {
                            if (event.kind === 5) {
                                status = 'deleted';
                            } else {
                                status = 'available';
                            }
                        } else if (type === "EOSE") {
                            if (status === 'unknown' && ws.readyState === WebSocket.OPEN) {
                                ws.close();
                                resolve({ relay, status });
                            }
                        }
                    };

                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.close();
                        }
                        resolve({ relay, status });
                    }, 3000);

                    ws.onerror = () => {
                        resolve({ relay, status: 'unknown' });
                    };
                } catch (error) {
                    resolve({ relay, status: 'unknown' });
                }
            });
        }

        async function updateRelayStatuses(eventId) {
            const statusDiv = document.getElementById(`relay-statuses-${eventId}`);
            if (!statusDiv) return;

            const statuses = await Promise.all(
                DEFAULT_RELAYS.map(relay => checkEventStatusOnRelay(relay, eventId))
            );

            const statusHtml = statuses.map(({ relay, status }) => `
                <div>
                    <span class="relay-status ${status}"></span>
                    ${relay}: ${status}
                </div>
            `).join('');

            statusDiv.innerHTML = `
                <div style="margin-top: 10px; font-size: 12px;">
                    <div style="margin-bottom: 5px;">Event status on relays:</div>
                    ${statusHtml}
                </div>
            `;
        }

        async function editList(eventId) {
            if (!currentUser) {
                alert('Please login first');
                return;
            }

            const listCard = document.querySelector(`[data-event-id="${eventId}"]`);
            const event = eventsMap.get(eventId);
            if (!event) {
                alert('List not found');
                return;
            }

            // Get current values
            const title = event.tags.find(t => t[0] === 'title' || t[0] === 't')?.[1] || '';
            const description = event.tags.find(t => t[0] === 'description' || t[0] === 'summary')?.[1] || event.content || '';
            const items = event.tags.filter(t => ['e', 'p', 'a', 'l'].includes(t[0]));

            // Create edit form
            const form = document.createElement('div');
            form.className = 'create-list-section';
            form.innerHTML = `
                <h2>Edit List</h2>
                <input type="text" id="edit-title" placeholder="List Title" value="${title}" required>
                <textarea id="edit-description" placeholder="List Description">${description}</textarea>
                <div id="edit-items">
                    ${items.map((item, index) => `
                        <div class="item-input">
                            <input type="text" value="${item[1]}" placeholder="URL, Note ID, or Profile">
                            <input type="text" value="${item[3] || ''}" placeholder="Title (optional)">
                            <button onclick="removeEditItem(${index})">Remove</button>
                        </div>
                    `).join('')}
                </div>
                <button onclick="addEditItem()">Add Item</button>
                <div class="button-group">
                    <button onclick="saveEdit('${eventId}')">Save Changes</button>
                    <button onclick="cancelEdit('${eventId}')">Cancel</button>
                </div>
            `;

            // Replace list content with form
            const content = listCard.querySelector('.list-content') || listCard.querySelector('.accordion-content');
            content.style.display = 'none';
            listCard.insertBefore(form, content);

            // Disable edit button
            const editButton = listCard.querySelector('.edit-button');
            editButton.disabled = true;
            editButton.classList.add('disabled');
        }

        async function saveEdit(originalEventId) {
            try {
                const listCard = document.querySelector(`[data-event-id="${originalEventId}"]`);
                const form = listCard.querySelector('.create-list-section');
                
                // Get form values
                const title = document.getElementById('edit-title').value.trim();
                const description = document.getElementById('edit-description').value.trim();
                const itemInputs = form.querySelectorAll('.item-input');
                
                if (!title) {
                    alert('Title is required');
                    return;
                }

                // Create tags array
                const tags = [
                    ['t', title],
                    ['description', description],
                    // Reference to previous version
                    ['e', originalEventId, 'reply']
                ];

                // Add items
                itemInputs.forEach(item => {
                    const [urlInput, titleInput] = item.querySelectorAll('input');
                    const url = urlInput.value.trim();
                    const itemTitle = titleInput.value.trim();
                    
                    if (url) {
                        if (url.startsWith('https://') || url.startsWith('http://')) {
                            tags.push(['l', url, '', itemTitle || url]);
                        } else if (url.startsWith('npub1')) {
                            tags.push(['p', url, '', itemTitle || 'Profile']);
                        } else {
                            tags.push(['e', url, '', itemTitle || 'Note']);
                        }
                    }
                });

                // Create new event
                const event = {
                    kind: 30003,
                    created_at: Math.floor(Date.now() / 1000),
                    tags,
                    content: description
                };

                const signedEvent = await window.nostr.signEvent(event);
                
                // Publish new version
                let published = false;
                for (const relay of DEFAULT_RELAYS) {
                    if (published) break;
                    published = await publishToRelay(relay, signedEvent);
                }

                if (!published) {
                    throw new Error('Failed to publish update to any relay');
                }

                // Create deletion event for old version
                const deletionEvent = {
                    kind: 5,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['e', originalEventId]]
                };

                const signedDeletion = await window.nostr.signEvent(deletionEvent);
                
                // Publish deletion
                published = false;
                for (const relay of DEFAULT_RELAYS) {
                    if (published) break;
                    published = await publishToRelay(relay, signedDeletion);
                }

                // Update UI
                cancelEdit(originalEventId);
                
                // Refresh lists
                const pubkeyInput = document.getElementById('pubkey');
                if (pubkeyInput.value) {
                    fetchLists();
                }

            } catch (error) {
                alert('Error saving changes: ' + error.message);
            }
        }

        function cancelEdit(eventId) {
            const listCard = document.querySelector(`[data-event-id="${eventId}"]`);
            const form = listCard.querySelector('.create-list-section');
            const content = listCard.querySelector('.list-content') || listCard.querySelector('.accordion-content');
            
            // Remove form and show content
            form.remove();
            content.style.display = 'block';

            // Re-enable edit button
            const editButton = listCard.querySelector('.edit-button');
            editButton.disabled = false;
            editButton.classList.remove('disabled');
        }

        function addEditItem() {
            const itemsDiv = document.getElementById('edit-items');
            const newItem = document.createElement('div');
            newItem.className = 'item-input';
            newItem.innerHTML = `
                <input type="text" placeholder="URL, Note ID, or Profile">
                <input type="text" placeholder="Title (optional)">
                <button onclick="this.parentElement.remove()">Remove</button>
            `;
            itemsDiv.appendChild(newItem);
        }

        function removeEditItem(index) {
            const items = document.getElementById('edit-items');
            items.children[index].remove();
        }

        // Keep track of all events for editing
        const eventsMap = new Map();

        function displayLists(events, deletions) {
            // Update eventsMap for editing
            events.forEach(event => eventsMap.set(event.id, event));

            // ... rest of the displayLists function ...

                // Add edit button if it's the current user's list and not deleted
                const editButton = currentUser && currentUser === event.pubkey && !isDeleted ? 
                    `<button onclick="editList('${event.id}')" class="edit-button">Edit List</button>` : '';

                // Check if this is an updated version
                const isUpdate = event.tags.find(t => t[0] === 'e' && t[2] === 'reply');
                const versionBadge = isUpdate ? 
                    `<span class="version-badge">Edited</span>` : '';

                return `
                    <div class="list-card ${isDeleted ? 'deleted' : ''}" data-event-id="${event.id}">
                        <div class="list-header">
                            <h3 class="list-title">${title}${isDeleted ? ' (Deleted)' : ''}${versionBadge}</h3>
                            <div class="button-group">
                                ${editButton}
                                ${deleteButton}
                            </div>
                        </div>
{{ ... }}
